#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import re
import json
import time
import argparse
import socket
import signal
import logging as log

from queue import Queue
from multiprocessing.pool import ThreadPool

from reqstat import config as rconf
from reqstat import logprocessor

def start_workers(pool, threads, queue, config):
    workers = []

    for i in range(threads):
        workers += [
            pool.apply_async(logprocessor.process_queue,
                             (queue, config["input"], config["metrics"]))
        ]

    return workers

def stop_workers(workers, queue):
    for w in workers:
        queue.put(None) # will be recognized as terminate command

def receive_stats(workers):
    result = []

    for w in workers:
        result.append(w.get())

    return result

def merge_stats(*stats):
    result = {}

    for s in list(stats):
        for k,v in s.items():
            if not k in result:
                result[k] = {}

            for kk,vv in v.items():
                if not kk in result[k]:
                    result[k][kk] = 0

                result[k][kk] += s[k][kk]

    return result

def main():
    log.basicConfig(format="%(levelname)s: %(message)s")

    parser = argparse.ArgumentParser()
    parser.add_argument("--version", action="version", version="%(prog)s 0.0.1",
                        help="print program version")
    parser.add_argument("--config", metavar="CONFIG", type=str, default="/etc/reqstat/reqstat.yml",
                        help="path to config file")
    args = parser.parse_args()

    try:
        config = rconf.load(args.config) # parse and validate
    except rconf.ConfigError as e:
        log.error(e)
        sys.exit(1)

    # Runtume stats received from workers will be stored here
    stats = {}

    # Queue for incoming messages (log entries)
    queue = Queue()

    # Workers pool
    workers_count = config["global"]["worker"]["threads"]
    workers_pool = ThreadPool(processes=workers_count)
    workers = start_workers(workers_pool, workers_count, queue, config)

    # Input (single) process
    reader_pool = ThreadPool(processes=1)
    reader_options = (queue, config["input"]["listen"]["ip"], config["input"]["listen"]["port"])
    reader = reader_pool.apply_async(logprocessor.receive_messages, reader_options)

    # Control socket
    socket_path = config["global"]["socket"]

    if os.path.exists(socket_path):
        os.remove(socket_path)

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(socket_path)
    sock.listen(1)

    # Main loop for control messages
    try:
        while True:
            connection, client_address = sock.accept()

            data = connection.recv(1024)
            if not data:
                continue

            command = data.decode("utf-8").strip()

            if command == "stats":
                # Restart workers to receive stats
                stop_workers(workers, queue)
                stats = merge_stats(stats, *receive_stats(workers))
                workers = start_workers(workers_pool, workers_count, queue, config)

                # Return currents stats to client
                response = json.dumps(stats, indent=4, sort_keys=False)
                connection.sendall(response.encode("utf-8"))

            else:
                connection.sendall("Unknown command".encode("utf-8"))

            connection.close()

    except (EOFError, KeyboardInterrupt):
        pass

    sock.close()
    os.remove(socket_path)

    stop_workers(workers, queue)
    receive_stats(workers) # waiting workers to finish gracefully

if __name__ == "__main__":
    main()
